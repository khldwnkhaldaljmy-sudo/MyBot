# ğŸ¬ Max-Quality Telegram Video Compressor Bot
# ğŸ”¥ Professional Telegram Bot For Ultra-High Quality Video Compression
# Built using Python + Telethon + FFmpeg to compress videos under 50MB
# while preserving maximum clarity via adaptive bitrate, resolution, and motion analysis.

# =================== 1. ØªØ«Ø¨ÙŠØª Ø§Ù„Ù…ÙƒØªØ¨Ø§Øª ===================
!pip install telethon yt-dlp nest_asyncio

import os
import subprocess
import asyncio
import time
import nest_asyncio
from telethon import TelegramClient, events

# =================== 2. Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¨ÙˆØª ===================
API_ID = 1234567           # Ø¶Ø¹ Ø±Ù‚Ù… ID Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ
API_HASH = 'YOUR_HASH'     # Ø¶Ø¹ Ø§Ù„Ù€ Hash Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ
BOT_TOKEN = 'YOUR_TOKEN'   # Ø¶Ø¹ ØªÙˆÙƒÙ† Ø§Ù„Ø¨ÙˆØª Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ

# =================== 3. ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ø¨ÙˆØª ===================
nest_asyncio.apply()
client = TelegramClient('colab_session', API_ID, API_HASH)

# Ø·Ø§Ø¨ÙˆØ± Ø§Ù„Ù…Ù‡Ø§Ù… ÙˆØ­Ø§Ù„Ø© Ø§Ù„Ø¨ÙˆØª
video_queue = asyncio.Queue()
current_task = {
    "status": "Ø®Ø§Ù…Ù„",
    "filename": "",
    "start_time": 0,
    "duration": 0
}

# =================== 4. Ø¯ÙˆØ§Ù„ Ù…Ø³Ø§Ø¹Ø¯Ø© ===================
def get_duration(path):
    """Ø§Ø³ØªØ®Ø¯Ø§Ù… ffprobe Ù„Ø­Ø³Ø§Ø¨ Ù…Ø¯Ø© Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ø¨Ø¯Ù‚Ø© Ø¹Ø§Ù„ÙŠØ©"""
    try:
        result = subprocess.run(
            ['ffprobe', '-v', 'error', '-show_entries',
             'format=duration', '-of',
             'default=noprint_wrappers=1:nokey=1', path],
            stdout=subprocess.PIPE, stderr=subprocess.STDOUT
        )
        return float(result.stdout)
    except:
        return 0

def compress_video(input_path, output_path, duration, target_mb=48):
    """Ø¶ØºØ· Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ø¨Ø¯Ù‚Ø© Ù…Ø¹ Ø¶Ù…Ø§Ù† Ø§Ù„Ø­Ø¬Ù… ØªØ­Øª 50MB"""
    audio_kbps = 128
    total_bitrate_kbps = (target_mb * 8192) / duration
    video_kbps = int(total_bitrate_kbps - audio_kbps)

    # Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰ Ù„Ø¶Ù…Ø§Ù† Ø¹Ø¯Ù… Ø§Ù†Ù‡ÙŠØ§Ø± Ø§Ù„Ø¬ÙˆØ¯Ø©
    if video_kbps < 150:
        video_kbps = 150

    # Ø§Ø®ØªÙŠØ§Ø± preset Ø­Ø³Ø¨ Ø·ÙˆÙ„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ
    chosen_preset = 'slower' if duration <= 1500 else 'veryslow'

    # Ù…Ø­Ø§ÙˆÙ„Ø© Ø¶ØºØ· Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ø¨Ø¯Ù‚Ø© 480p Ø£ÙˆÙ„Ø§Ù‹
    base_cmd = [
        'ffmpeg', '-y', '-i', input_path,
        '-vf', 'scale=854:480:flags=lanczos',
        '-c:v', 'libx264',
        '-preset', chosen_preset,
        '-crf', '18',
        '-b:v', f'{video_kbps}k',
        '-maxrate', f'{video_kbps}k',
        '-bufsize', f'{video_kbps*2}k',
        '-x264-params', 'ref=4:me=umh:subme=8:trellis=2:direct=auto:aq-mode=3',
        '-pix_fmt', 'yuv420p',
        '-c:a', 'aac',
        '-b:a', f'{audio_kbps}k',
        '-movflags', '+faststart'
    ]

    subprocess.run(base_cmd + [output_path], check=True)

    # Ø¥Ø°Ø§ ØªØ¬Ø§ÙˆØ² Ø§Ù„Ø­Ø¬Ù… 50MBØŒ Ø¥Ø¹Ø§Ø¯Ø© ØªØ±Ù…ÙŠØ² Ø¥Ù„Ù‰ 360p Ù„Ø¶Ù…Ø§Ù† Ø¹Ø¯Ù… ÙˆØ¬ÙˆØ¯ Ø¯ØºØ¨Ø´Ø©
    if os.path.getsize(output_path) / (1024*1024) > 50:
        fallback_cmd = [
            'ffmpeg', '-y', '-i', input_path,
            '-vf', 'scale=640:360:flags=lanczos',
            '-c:v', 'libx264',
            '-preset', 'slower',
            '-crf', '20',
            '-b:v', f'{video_kbps//2}k',
            '-maxrate', f'{video_kbps//2}k',
            '-bufsize', f'{video_kbps}k',
            '-x264-params', 'ref=4:me=umh:subme=8:trellis=2:direct=auto:aq-mode=3',
            '-pix_fmt', 'yuv420p',
            '-c:a', 'aac',
            '-b:a', f'{audio_kbps}k',
            '-movflags', '+faststart'
        ]
        subprocess.run(fallback_cmd + [output_path], check=True)

    return True

# =================== 5. ÙˆØ¸ÙŠÙØ© Ø§Ù„Ø¹Ø§Ù…Ù„ ===================
async def worker():
    """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø¶ØºØ· Ø§Ù„ÙÙŠØ¯ÙŠÙˆÙ‡Ø§Øª ÙÙŠ Ø§Ù„Ø®Ù„ÙÙŠØ©"""
    while True:
        event, inp_path, out_path, custom_caption = await video_queue.get()
        current_task["start_time"] = time.time()
        current_task["filename"] = custom_caption

        try:
            current_task["status"] = "ğŸ“¥ Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù…ÙŠÙ„ Ù…Ù† ØªÙŠÙ„ÙŠØ¬Ø±Ø§Ù…..."
            await event.download_media(inp_path)

            vid_duration = get_duration(inp_path)
            current_task["duration"] = vid_duration

            current_task["status"] = "ğŸ¬ Ø¬Ø§Ø±ÙŠ Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø© (ØªØ­Ù„ÙŠÙ„ Ø­Ø±ÙƒØ© Ù…ÙƒØ«Ù)..."
            loop = asyncio.get_event_loop()
            await loop.run_in_executor(None, compress_video, inp_path, out_path, vid_duration)

            current_task["status"] = "ğŸ“¤ Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø±ÙØ¹..."
            size = os.path.getsize(out_path) / (1024 * 1024)

            await event.client.send_file(
                event.chat_id,
                out_path,
                caption=f"âœ… ØªÙ… Ø§Ù„Ø¶ØºØ· Ø¨Ù†Ø¬Ø§Ø­\nğŸ“„ Ø§Ù„Ø¹Ù†ÙˆØ§Ù†: {custom_caption}\nğŸ“¦ Ø§Ù„Ø­Ø¬Ù…: {size:.2f} MB\nğŸ“º Ø§Ù„Ø¬ÙˆØ¯Ø©: 480p / 360p"
            )
        except Exception as e:
            await event.respond(f"âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©: {e}")
        finally:
            for f in [inp_path, out_path]:
                if os.path.exists(f): os.remove(f)
            video_queue.task_done()
            current_task["status"] = "ğŸŸ¢ Ø®Ø§Ù…Ù„"
            current_task["start_time"] = 0

# =================== 6. Ø§Ø³ØªÙ‚Ø¨Ø§Ù„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆÙ‡Ø§Øª ===================
@client.on(events.NewMessage(func=lambda e: e.video))
async def on_video_receive(event):
    custom_name = event.message.message or (event.file.name if event.file.name else "ÙÙŠØ¯ÙŠÙˆ Ø¨Ø¯ÙˆÙ† Ø¹Ù†ÙˆØ§Ù†")
    await video_queue.put((event, f"in_{event.id}.mp4", f"out_{event.id}.mp4", custom_name))
    await event.respond(f"ğŸ“¥ ØªÙ…Øª Ø§Ù„Ø¥Ø¶Ø§ÙØ© Ù„Ù„Ø·Ø§Ø¨ÙˆØ±:\nğŸ“ {custom_name}\nâš™ï¸ Ø³ÙŠØªÙ… Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù†Ø¸Ø§Ù… Ø§Ù„Ø¶ØºØ· Ø§Ù„Ø£Ù‚ØµÙ‰.")

# =================== 7. Ø£Ù…Ø± Ø­Ø§Ù„Ø© Ø§Ù„Ø¨ÙˆØª Ø¨Ø§Ù„Ø¹Ø±Ø¨ÙŠ ===================
@client.on(events.NewMessage(pattern='Ø¶'))
async def status_check(event):
    q_size = video_queue.qsize()
    if current_task["status"] == "ğŸŸ¢ Ø®Ø§Ù…Ù„" and q_size == 0:
        await event.respond("âœ… Ø§Ù„Ø¨ÙˆØª Ù…ØªØ§Ø­ Ø­Ø§Ù„ÙŠØ§Ù‹ ÙˆÙ„Ø§ ØªÙˆØ¬Ø¯ Ù…Ù‡Ø§Ù….")
        return

    elapsed_time = int(time.time() - current_task["start_time"]) if current_task["start_time"] > 0 else 0
    total_est = (q_size * 20) + (10 if current_task["duration"] <= 1500 else 45)

    status_msg = f"ğŸ“Š **ØªÙ‚Ø±ÙŠØ± Ø§Ù„Ø­Ø§Ù„Ø© Ø§Ù„Ù…ØªÙ‚Ø¯Ù…:**\n"
    status_msg += f"ğŸ”¹ Ø§Ù„ÙˆØ¶Ø¹: {current_task['status']}\n"
    if current_task['filename']:
        status_msg += f"ğŸ¬ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ø§Ù„Ø­Ø§Ù„ÙŠ: {current_task['filename']}\n"
        status_msg += f"â³ ÙˆÙ‚Øª Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø­Ø§Ù„ÙŠ: {elapsed_time // 60} Ø¯ Ùˆ {elapsed_time % 60} Ø«\n"
    status_msg += f"ğŸ“¦ ÙÙŠØ¯ÙŠÙˆÙ‡Ø§Øª ÙÙŠ Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±: {q_size}\n"
    status_msg += f"ğŸ•’ ØªÙ‚Ø¯ÙŠØ± Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±: {total_est} Ø¯Ù‚ÙŠÙ‚Ø©"
    
    await event.respond(status_msg)

# =================== 8. ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª ===================
async def start_bot():
    print("ğŸš€ Ø§Ù„Ø¨ÙˆØª ÙŠØ¹Ù…Ù„ Ø§Ù„Ø¢Ù† Ø¨Ø£Ø¹Ù„Ù‰ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø¬ÙˆØ¯Ø© ÙˆØ§Ù„Ø­Ø±ÙƒØ©...")
    await client.start(bot_token=BOT_TOKEN)
    asyncio.create_task(worker())
    await client.run_until_disconnected()

if __name__ == '__main__':
    loop = asyncio.get_event_loop()
    loop.run_until_complete(start_bot())
